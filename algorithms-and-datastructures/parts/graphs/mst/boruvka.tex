\newpage
\subsubsection{Boruvka's algorithm}
\begin{definition}[]{Definition of Borůvka's Algorithm}
    Borůvka's Algorithm is a greedy algorithm for finding the Minimum Spanning Tree (MST) of a connected, weighted graph. It repeatedly selects the smallest edge from each connected component and adds it to the MST, merging the components until only one component remains.
\end{definition}

\begin{properties}[]{Characteristics and Performance of Borůvka's Algorithm}
    \begin{itemize}
        \item \textbf{Graph Type:} Works on undirected, weighted graphs.
        \item \textbf{Approach:} Greedy, component-centric.
        \item \textbf{Time Complexity:} \tct{(|V| + |E|) \log(|V|)}.
        \item \textbf{Space Complexity:} Depends on the graph representation, typically \tct{E + V}.
        \item \textbf{Limitations:} Efficient for parallel implementations but less commonly used in practice compared to Kruskal's and Prim's.
    \end{itemize}
\end{properties}

\begin{algorithm}
    \caption{Borůvka's Algorithm}
    \begin{algorithmic}[1]
        \Procedure{Boruvka}{$G = (V, E)$}
            \State Initialize a forest $F$ with each vertex as a separate component.
            \State Initialize an empty MST $T$.
            \While{the number of components in $F > 1$}
                \State Initialize an empty set $minEdges$.
                \For{each component $C$ in $F$}
                    \State Find the smallest edge $(u, v)$ such that $u \in C$ and $v \notin C$.
                    \State Add $(u, v)$ to $minEdges$.
                \EndFor
                \For{each edge $(u, v)$ in $minEdges$}
                    \If{$u$ and $v$ are in different components in $F$}
                        \State Add $(u, v)$ to $T$.
                        \State Merge the components containing $u$ and $v$ in $F$.
                    \EndIf
                \EndFor
            \EndWhile
            \State \Return $T$.
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\begin{usage}[]{Borůvka's Algorithm}
    Borůvka's algorithm finds the Minimum Spanning Tree (MST) by repeatedly finding the smallest outgoing edge from each connected component.

    \begin{enumerate}
        \item \textbf{Initialize:}
              \begin{itemize}
                  \item Assign each vertex to its own component.
              \end{itemize}

        \item \textbf{Find Smallest Edges:}
              \begin{itemize}
                  \item For each component, find the smallest outgoing edge. After combination, the other vertex will only be evaluated if it has an even lower weight edge outgoing from it.
              \end{itemize}

        \item \textbf{Merge Components:}
              \begin{itemize}
                  \item Add the selected edges to the MST.
                  \item Merge the connected components of the graph.
              \end{itemize}

        \item \textbf{Repeat:}
              \begin{itemize}
                  \item Repeat steps 2-3 until only one component remains (all vertices are connected).
              \end{itemize}

        \item \textbf{End:}
              \begin{itemize}
                  \item The MST is complete, and all selected edges form a connected acyclic graph.
              \end{itemize}
    \end{enumerate}
\end{usage}



% \newpage
% \subsection{Example: Electrification of Möhrens}
% \begin{figure*}[ht]
%     \centering
%     \begin{tikzpicture}
%         \tikzset{enclosed/.style={draw, circle, inner sep=0pt, minimum size =.5cm, circle}};
%         \node[enclosed, label={center: $\lightning$}] (power) at (0, 0) {};
%         \node[enclosed, label={center: A}] (A) at (-1, 1) {};
%         \node[enclosed, label={center: B}] (B) at (-1, 0) {};
%         \node[enclosed, label={center: C}] (C) at (-1, -1) {};
%         \node[enclosed, label={center: D}] (D) at (1, 1) {};
%         \node[enclosed, label={center: E}] (E) at (1, 0) {};
%         \node[enclosed, label={center: F}] (F) at (1, -1) {};
%
%         \draw (A) -- node[left] {\scriptsize 3} ++ (B);
%         \draw (B) -- node[left] {\scriptsize 7} ++ (C);
%
%         \draw (D) -- node[right] {\scriptsize 30} ++ (E);
%         \draw (E) -- node[right] {\scriptsize 25} ++ (F);
%         \draw plot[smooth] coordinates {(C) (1.5, -1.5) (1.5, 0.8) (D)};
%         \node[label={\scriptsize 20}] at (1.8, -1.8) {};
%
%
%         \draw (A) -- node[right] {\scriptsize 10} ++ (power);
%         \draw (B) -- node[above,yshift=-0.1cm] {\scriptsize 5} ++ (power);
%         \draw (C) -- node[right] {\scriptsize 15} ++ (power);
%         \draw (D) -- node[left] {\scriptsize 40} ++ (power);
%         \draw (E) -- node[above,yshift=-0.1cm] {\scriptsize 0} ++ (power);
%         \draw (F) -- node[left] {\scriptsize 35} ++ (power);
%     \end{tikzpicture}
% \end{figure*}
%
% \fhlc{Aquamarine}{Goal:} Find sub-graph for which the weights are minimal.
%
% $G = (V, E)$ is non-directed, connected.
%
% \fhlc{lightgray}{Weights of edges:} $\{w(e)\}\rvert_{e \in E}$ (non-negative)\\[0.2cm]
% \fhlc{lightgray}{Spanning edges $A\subseteq E$} Graph $(V, A)$ is connected\\[0.2cm]
% \fhlc{lightgray}{Weight:} $w(A) := \sum_{e \in A} w(e)$\\[0.2cm]
