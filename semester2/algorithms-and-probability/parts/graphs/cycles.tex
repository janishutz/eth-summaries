\newpage
\subsection{Cycles}

\subsubsection{Eulerian cycles / circuits}
\begin{definition}[]{Eulerian cycle}
    A \textit{eulerian cycle} in a graph $G = (V, E)$ is a circuit (closed cycle) that contains each edge exactly once.
    If a graph contains a eulerian cycle, we call it \textit{eulerian}
\end{definition}
If $G$ contains a eulerian cycle, $\deg(v)$ of all vertices $v \in V$ is even. For connected graph, we even have a double-sided implication.

If we combine the entirety of the explanations of pages 43-45 in the script, we reach the following algorithm, where $N_G(v)$ is the function returning the neighbours of vertex $v$ in graph $G$:
\begin{algorithm}
    \caption{\textsc{EulerianCycle}$(G, v_{start})$}
    \begin{algorithmic}[1]
        \Procedure{RandomCycle}{$G, v_{start}$}
            \State $v \gets v_{start}$
            \State $W \gets \langle v \rangle$ \Comment{Prepare the cycle (add the start vertex to it)}
            \While{$N_G(v) \neq \emptyset$}
                \State Choose $v_{next}$ arbitrarily from $N_G(v)$ \Comment{Choose arbitrary neighbour}
                \State Attach $v_{next}$ to the cycle $W$
                \State $e \gets \{v, v_{next}\}$
                \State Delete $e$ from $G$
                \State $v \gets v_{next}$
            \EndWhile
            \State \Return $W$
        \EndProcedure
        \State $W \gets$ \Call{RandomCycle}{$v_{start}$} \Comment{Fast runner}
        \State $v_{slow} \gets$ start vertex of $W$
        \While{$v_{slow}$ is not the last vertex in $W$}
            \State $v \gets$ successor of $v_{slow}$ in $W$
            \If{$N_G(v) \neq \emptyset$}
                \State $W' \gets$ \Call{RandomCycle}{v}
                \State $W \gets W_1 + W' + W_2$ \Comment{We union the different branches of the Euler cycle}
            \EndIf
            \State $v_{slow} \gets$ successor of $v_{slow}$ in $W$
        \EndWhile
        \State \Return $W$
    \end{algorithmic}
\end{algorithm}

\begin{theorem}[]{Eulerian Graph}
    \begin{enumerate}[label=\alph*)]
        \item A connected graph $G$ is eulerian if and only if the degree of all vertices is even
        \item In a connected eulerian graph, we can find a eulerian cycle in $\tco{|E|}$
    \end{enumerate}
\end{theorem}


\newpage
\subsubsection{Hamiltonian Cycles}
\begin{definition}[]{Hamiltonian Cycle}
    A \textit{Hamiltonian Cycle} in a graph $G = (V, E)$ is a cycle passing through each vertex \textit{exactly once}.
    If a graph contains a Hamiltonian cycle, we call it \textit{Hamiltonian}
\end{definition}
A classic example here is the Travelling Salesman Problem (TSP), covered later on.

The issue with Hamiltonian cycles is that the problem is $\mathcal{N}\mathcal{P}$-complete, thus it is assumed that there does not exist an algorithm that can determine if a graph is Hamiltonian in polynomial time.

\stepcounter{all}
\begin{theorem}[]{Hamiltonian Cycle Algorithm}
    The algorithm \textsc{HamiltonianCycle} is correct and has space complexity $\tco{n \cdot 2^n}$ and time complexity $\tco{n^2 \cdot 2^n}$, where $n = |V|$
\end{theorem}

In the below algorithm, $G = (V, E)$ is a graph for which $V = [n]$ and $N(v)$ as usual the neighbours of $v$ and we define $S$ as a subset of the vertices of $G$ with $1 \in S$.
We define
\begin{align*}
    P_{S, x} := \begin{cases}
                    1 & \text{exists a $1$-$x$-path in $G$ that contains exactly the vertices of $S$} \\
                    0 & \text{else}
                \end{cases}
\end{align*}
We then have:
\begin{align*}
    G \text{ contains a Hamiltonian cycle } \Longleftrightarrow \exists x \in N(1) \text{ with } P_{[n], x} = 1
\end{align*}
Or in words, a graph contains a Hamiltonian Cycle if and only if for any of the neighbours of vertex $1$, our predicate $P_{S, x} = 1$ for $S = V = [n]$ and $x$ being that vertex in the neighbours set $N(1)$.

This means, we have found a recurrence relation, albeit an exponential one.
\begin{algorithm}
    \caption{\textsc{HamiltonianCycle}$(G=([n], E))$}
    \begin{algorithmic}[1]
        \For{\textbf{all} $x \in [n], x \neq 1$} \Comment{Initialization}
            \State $\displaystyle P_{\{1, x\}, x} :=
                \begin{cases}
                    1 & \text{if } \{1, x\} \in E \\
                    0 & \text{else}
                \end{cases}$
        \EndFor

        \For{$s = 3, \ldots, n$} \Comment{Recursion}
            \For{\textbf{all} $S \subseteq [n]$ with $1 \in S$ and $|S| = s$} \Comment{See implementation notes in Section \ref{sec:implementation}}
                \For{\textbf{all} $x \in S, x\neq 1$} \Comment{Fill table for all $x$ in the subset}
                    \State $P_{S, x} = \max\{P_{S\backslash \{x\}, x'} \divides x' \in S \cap N(x), x' \neq 1\}$
                \EndFor
            \EndFor
        \EndFor

        \If{$\exists x \in N(1)$ with $P_{[n], x} = 1$} \Comment{Check condition}
            \State \Return \verb|true|
        \Else
            \State \Return \verb|false|
        \EndIf
    \end{algorithmic}
\end{algorithm}

\newpage
\fhlc{Cyan}{Improved algorithm}

There are algorithms that can find Hamiltonian cycles without using exponential memory usage.
The concept for that is the inclusion-exclusion principle (more on that in Section \ref{sec:prob-basics})

\begin{theorem}[]{Inclusion-Exclusion-Principle}
    For finite sets $A_1, \ldots, A_n$ ($n \geq 2$) we have
    \begin{align*}
        \left| \bigcup_{i = 1}^n A_i \right| & = \sum_{l = 1}^{n}\left((-1)^{l + 1} \sum_{1 \leq i_1 < \dots < i_l \leq n} |A_{i_1} \cap \ldots \cap A_{i_l}|\right)                                                                                              \\
                                             & = \sum_{i = 1}^{n}|A_i| - \sum_{1 \leq i_1 < i_2 \leq n}|A_{i_1} \cap A_{i_2}| + \sum_{1 \leq i_1 < i_2 < i_3 \leq n} |A_{i_1} \cap A_{i_2} \cap A_{i_3}| - \ldots + (-1)^{n + 1} \cdot |A_1 \cap \ldots \cap A_n|
    \end{align*}
\end{theorem}

Since it is easier to find walks compared to paths, we define for all subsets $S \subseteq [n]$ with $v \notin S$ for a start vertex $s \in V$
\begin{align*}
    W_S := \{ \text{\textit{walks} of length $n$ in $G$ with start and end vertex $s$ that doesn't visit any vertices of }S \}
\end{align*}
We thus reach the following algorithm:
\begin{algorithm}
    \caption{\textsc{CountHamiltionianCycles}$(G = ([n], E))$}
    \begin{algorithmic}[1]
        \State $s \gets 1$ \Comment{Start vertex, can be chosen arbitrarily}
        \State $Z \gets |W_{\emptyset}|$ \Comment{All possible paths with length $n$ in $G$}
        \For{\textbf{all} $S \subseteq [n]$ with $s \notin S$ and $S \neq \emptyset$}
            \State Compute $|W_S|$ \Comment{With adjacency matrix of $G[V\backslash S]$}
            \State $Z \gets Z + (-1)^{|S|}|W_S|$ \Comment{Inclusion-Exclusion}
        \EndFor
        \State $Z \gets \frac{Z}{2}$ \Comment{There are two cycles for each \textit{true} cycle (in both directions, we only care about one)}
        \State \Return $Z$ \Comment{The number of Hamiltonian cycles in $G$}
    \end{algorithmic}
\end{algorithm}

\begin{theorem}[]{Count Hamiltionian Cycles Algorithm}
    The algorithm computes the number of Hamiltonian cycles in $G$ with space complexity $\tco{n^2}$ and time complexity $\tco{n^{2.81}\log(n) \cdot 2^n}$, where $n = |V|$
\end{theorem}
The time complexity bound comes from the fact that we need $\tco{\log(n)}$ matrix multiplications to compute $|W_S|$, which can be found in entry $(s, s)$ in $(A_S)^n$, where $A_S$ is the adjacency matrix of the induced subgraph $G[V\backslash S]$.
Each matrix multiplication can be done in $\tco{n^{2.81}}$ using Strassen's Algorithm.
The $2^n$ is given by the fact that we have that many subsets to consider.


\newpage
\subsubsection{Special cases}
\stepcounter{all}
\begin{lemma}[]{Bipartite graph}
    If $G = (A \uplus B, E)$ is a bipartite graph with $|A| \neq |B|$, $G$ cannot contain a Hamiltonian cycle
\end{lemma}

A hypercube $H_d$ with dimension $d$ has the vertex set $\{0, 1\}^d$.
Two vertices are connected if and only if their $0$-$1$-sequences differ in exactly one bit.
\begin{center}
    \fbox{
        \textit{
            Every hypercube of dimension $d \geq 2$ has a Hamiltonian cycle
        }
    }
\end{center}
Grid graphs (also known as mesh graphs) are graphs laid out in a (typically) square grid of size $m \times n$
\begin{center}
    \fbox{
        \parbox{15cm}{
            A grid graph contains a Hamiltonian cycle if and only if $n$ or $m$ (or both) are even. If both are odd, there is no Hamiltonian cycle
        }
    }
\end{center}

\stepcounter{all}
\begin{theorem}[]{Dirac}
    If $G$ is a graph with $|V| \geq 3$ vertices, for which every vertex has at least $\frac{|V|}{2}$ neighbours, $G$ is Hamiltonian.
\end{theorem}
In other words, every graph with minimum degree $\frac{|V|}{2}$ is Hamiltonian.



\subsubsection{Travelling Salesman Problem}

Given a graph $K_n$ and a function $\displaystyle l : {[n] \choose 2} \rightarrow \N_0$ that assigns a length to each edge of the graph, we are looking for a Hamiltonian cycle $C$ in $K_n$ with
\begin{align*}
    \sum_{e \in C} l(e) = \min \left\{ \sum_{e \in C'} l(e) \divides C' \text{ is a Hamiltonian cycle in } K_n \right\}
\end{align*}
In words, we are looking for the hamiltonian cycle with the shortest length among all hamiltonian cycles.

\stepcounter{all}
\begin{theorem}[]{Travelling Salesman Problem}
    If there exists for $\alpha > 1$ a $\alpha$-approximation algorithm for the travelling salesman problem with time complexity $\tco{f(n)}$, there also exists an algorithm that can decide if a graph with $n$ vertices is Hamiltonian in $\tco{f(n)}$.
\end{theorem}
This obviously means that this problem is also $\mathcal{N}\mathcal{P}$-complete.
If we however use the triangle-inequality $l(\{x, z\}) \leq l(\{x, y\}) + l(\{y, z\}))$, which in essence says that a direct connection between two vertices has to always be shorter or equally long compared to a direct connection (which intuitively makes sense),
we reach the metric travelling salesman problem, where, given a graph $K_n$ and a function $l$ (as above, but this time respecting the triangle-inequality), we are again looking for the same answer as for the non-metric problem.

\begin{theorem}[]{Metric Travelling Salesman Problem}
    There exists a $2$-approximation algorithm with time complexity $\tco{n^2}$ for the metric travelling salesman problem.
\end{theorem}

\shortproof This algorithm works as follows: Assume we have an MST and we walk around the outside of it. 
Thus, the length of our path is $2$ \verb|mst|($K_n, l$). 
If we now use the triangle inequality, we can skip a few already visited vertices and at least not lengthen our journey around the outside of the MST.
Any Hamiltonian cycle can be transformed into an MST by removing an arbitrary edge from it.
Thus, for the optimal length (minimal length) of a Hamiltonian cycle, we have $\text{opt}(K_n, l) \geq \verb|mst|(K_n, l)$. 
If we now double the edge set (by duplicating each edge), then, since for $l(C) = \sum_{e \in C} l(e)$ for our Hamiltonian cycle $C$, we have $l(C) \leq 2 \text{opt}(K_n, l)$, we can simply find a eulerian cycle in the graph in $\tco{n}$, and since it takes $\tco{n^2}$ to compute an MST, our time complexity is $\tco{n^2}$

