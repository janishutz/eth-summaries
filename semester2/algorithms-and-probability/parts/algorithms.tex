\newsection
\section{Algorithms}
\subsection{Graph algorithms}

\subsubsection{Long path problem}
Given a tuple $(G, B)$ where $G$ is a graph and $B \in \N_0$, we need to determine whether there exists a path of length $B$ in $G$.

This problem is another one of the infamous $\mathcal{N}\mathcal{P}$-Complete problems, for which there \textit{supposedly} doesn't exist an algorithm that can solve the problem in polynomial time.
We can show that this problem belongs to said group if we can show that we can \textit{efficiently} construct a graph $G'$ with $n' \leq 2n - 2$ vertices such that $G$ has a Hamiltonian Cycle if and only if $G'$ has a path of length $n$.

We construct a graph $G'$ from graph $G$ by selecting a vertex $v$ and replacing each edge incident to that vertex with edges that lead to newly added vertices $\hat{w_1}, \hat{w_2}, \ldots$.
$G'$ has $(n - 1) + \deg(v) \leq 2n - 2$ vertices. All the vertices $\hat{w_1}, \ldots, \hat{w_{\deg(v)}}$ all have degree $1$.

The graph $G'$ fulfills the above implication because
\begin{enumerate}[label=(\roman*)]
    \item Let $\langle v_1, v_2, \ldots, v_n, v_1 \rangle$ be a Hamiltonian cycle.
          Assume for contradiction that the resulting graph, constructed according to the description above does not contain a path of length $n$.
          Let's assume $v_1 = v$ (the vertex removed during construction). However, $\langle \hat{v_2}, v_2, \ldots, \hat{v_n}, v_n \rangle$ is a path of length $n$
    \item Let $\langle u_0, u_1, \ldots, u_n \rangle$ be a path of length $n$ in $G'$ and let $\deg(u_i) \geq 2 \smallhspace \forall i \in \{1, \ldots, n - 1\}$ These vertices hence have to be the $n - 1$ remaining vertices of $G$, thus we have $u_0 = \hat{w_i}$ and $u_n = \hat{w_j}$ two different ones of new vertices of degree $1$ in $G'$. Thus, we have $u_1 = w_i$ and $u_{n - 1} = w_j$ and we have $\langle v, u_1, \ldots, u_{n - 1}, v \rangle$, which is a Hamiltonian cycle in $G$
\end{enumerate}
Due to the construction of the graph $G'$ we can generate it from $G$ in \tco{n^2} steps. We thus have:

\begin{theorem}[]{Long Path Problem}
    If we can find a \textit{long-path} in a graph with $n$ vertices in time $t(n)$, we can decide if a graph with $n$ vertices has a Hamiltonian cycle in $t(2n - 2) + \text{\tco{n^2}}$
\end{theorem}


\fhlc{Cyan}{Short long paths}

In biological applications, the long paths searched are usually small compared to $n$. It is possible to solve this problem in polynomial time if for the tuple $(G, B)$ $B = \log(n)$.

Notation and useful properties:
\begin{itemize}
    \item $[n] := \{1, 2, \ldots, n\}$. $[n]^k$ is the set of sequences over $[n]$ of length $k$ and we have $\left| [n]^k \right| = n^k$. ${[n] \choose k}$ is the set of subsets of $[n]$ of cardinality $k$ and we have $\left| {[n] \choose k} \right| = {n \choose k}$
    \item For every graph $G = (V, E)$ we have $\sum_{v \in V} \deg(v) = 2|E|$
    \item $k$ vertices (no matter if part of a path or not) can be coloured using $[k]$ in exactly $k^k$ ways whereas $k!$ of said colourings use each colour exactly once.
    \item For $c, n \in \R^+$ we have $c^{\log(n)} = n^{\log(c)}$
    \item For $n \in \N_0$ we have $\sum_{i = 0}^{n} {n \choose i} = 2^n$. (Application of binomial expansion, see \ref{sec:binomial-expansion})
    \item For $n \in \N_0$ we have $\frac{n!}{n^n} \geq e^{-n}$
    \item If we repeat an experiment with probability of success $p$ until success, $\E[\mathcal{X}] = \frac{1}{p}$ where $\mathcal{X} :=$ number of trials
\end{itemize}


\newpage
\shade{ForestGreen}{Colourful paths}

A path is called \textit{colourful} if all vertices on it are coloured differently.
For $v \in V$ and $i \in \N_0$ let's define
\begin{align*}
    P_i(v) := \left\{ S \in {[k] \choose i + 1} \smallhspace \Bigg| \smallhspace \exists \text{ path ending in $v$ coloured with $S$ colours } \right\}
\end{align*}
Thus, $P_i(v)$ contains a set $S$ of $i + 1$ colours if and only if there exists a path with vertex $v$ whose colours are the colours in $S$.
It is important to note that such a path has to be always \textit{exactly} of length $i$.

If we solve this problem for every $v \in V$, we solved our problem and we have
\begin{align*}
    \exists \text{ colourful path of length $k - 1$ } \Longleftrightarrow \bigcup_{v \in V} P_{k - 1}(v) \neq \emptyset
\end{align*}
For the algorithm, we need to also define $N(v)$ which returns the neighbours of $v$ and $\gamma: V \rightarrow [k]$ which assigns a colour to each vertex.

\begin{algorithm}
    \caption{Colourful path algorithm}
    \begin{algorithmic}[1]
        \Procedure{Colourful}{$G, i$}
            \For{\textbf{all} $v \in V$}
                \State $P_i(v) \gets \emptyset$
                \For{\textbf{all} $x \in N(v)$}
                    \For{\textbf{all} $R \in P_{i - 1}(x)$ with $\gamma(v) \notin R$}
                        \State $P_i(v) \gets P_i(v) \cup \{R \cup \{\gamma(v)\}\}$
                    \EndFor
                \EndFor
            \EndFor
        \EndProcedure
    \end{algorithmic}
\end{algorithm}
The time complexity of this algorithm is \tco{2^k km}. If we now have $k = \text{\tco{\log(n)}}$, the algorithm is polynomial.


\shade{ForestGreen}{Random colouring}

The idea to solve the short long path problem in polynomial time is to randomly colour the vertices using colours $[k]$, whereby $k := B + 1$ and check if there is a colourful path of length $k - 1$.
Since we are guaranteed to have a colourful path if we find one, we can develop a Las Vegas Algorithm that solves this problem. But first
\begin{theorem}[]{Random Colouring}
    Let $G$ be a graph with a path of length $k - 1$
    \begin{enumerate}[label=(\arabic*)]
        \item We have $p_{\text{success}} = \Pr[\exists \text{ colourful path of length } k - 1] \geq \Pr[P \text{ is colourful}] = \frac{k!}{k^k} \geq e^{-k}$
        \item The expected number of trials required to get a colourful path of length $k - 1$ is $\frac{1}{p_{\text{success}}} \leq e^k$
    \end{enumerate}
\end{theorem}
For our algorithm we choose a $\lambda > 1 \in \R$ and we repeat the test at most $\ceil{\lambda e^k}$. If we succeed once, we abort and output ``\textsc{Yes}''. If we haven't succeeded in any of the trials, we output ``\textsc{No}''

\begin{theorem}[]{Random Colouring Algorithm}
    \begin{itemize}
        \item Time complexity: \tco{\lambda(2e)^k km}
        \item If we return ``\textsc{Yes}'', the graph is \textit{guaranteed} to contain a path of length $k - 1$
        \item If we return ``\textsc{No}'', the probability of false negative is $e^{-\lambda}$
    \end{itemize}
\end{theorem}



\newpage
\setcounter{all}{4}
\subsubsection{Flows}
\begin{definition}[]{Network}
    A \textit{Network} is a tuple $N = (\mathcal{V}, \mathcal{A}, c, s, t)$ whereby
    \begin{itemize}
        \item $(\mathcal{V}, \mathcal{A})$ is a directed graph
        \item $c: \mathcal{A} \rightarrow \R_0^+$ the \textit{capacity function}
        \item $s \in \mathcal{V}$ is the \textit{source}
        \item $t \in \mathcal{V}\backslash \{s\}$ is the \textit{target}
    \end{itemize}
\end{definition}
The capacity function hereby describes the maximum flow through each edge. For each vertex that is not the source or target, the flow is constant, i.e. the total amount entering vertex $v$ has to be equal to the amount exiting it again.

\begin{definition}[]{Flow}
    Given a network $N = (\mathcal{V}, \mathcal{A}, c, s, t)$, a flow in said network is a function $f: \mathcal{A} \rightarrow \R$ where
    \begin{align*}
        0 \leq f(e) \leq c(e) \smallhspace \forall e \in \mathcal{A} \text{ The acceptability }
    \end{align*}
    \begin{align*}
        \forall v \in \mathcal{V} \backslash \{s, t\} \sum_{u \in \mathcal{V}: (u, v) \in \mathcal{A}} f(u, v) = \sum_{u \in \mathcal{V}: (v, u) \in \mathcal{A}} f(v, u) \text{ the conservation of flow }
    \end{align*}
    The value of a flow $f$ is given by
    \begin{align*}
        \text{val}(f) := \sum_{u \in \mathcal{V}: (s, u) \in \mathcal{A}} f(s, u) - \sum_{u \in \mathcal{V}: (u, s) \in \mathcal{A}} f(u, s)
    \end{align*}
    We call a flow \textit{integeral} if $f(e) \in \Z \smallhspace \forall e \in \mathcal{A}$
\end{definition}


\begin{lemma}[]{Flow}
    The total flow to the target equals the value of the flow, i.e.
    \begin{align*}
        \text{netinflow}(f) = \text{val}(f) = \sum_{u \in \mathcal{V} : (u, t) \in \mathcal{A}} f(u, t) - \sum_{u \in \mathcal{V}: (t, u) \in \mathcal{A}} f(t, u)
    \end{align*}
\end{lemma}


\begin{definition}[]{$s$-$t$-cut}
    An $s$-$t$-cut of a network $N = (\mathcal{V}, \mathcal{A}, c, s, t)$ is a partition $P = (\mathcal{S}, \mathcal{T})$ of $\mathcal{V}$ (i.e. $\mathcal{S} \cup \mathcal{T} = \mathcal{V}$ and $\mathcal{S} \cap \mathcal{T} = \emptyset$) where $s \in \mathcal{S}$ and $t \in \mathcal{T}$.
    The capacity of a $s$-$t$-cut is then given by
    \begin{align*}
        \text{cap}(\mathcal{S}, \mathcal{T}) = \sum_{(u, w) \in (\mathcal{S} \times \mathcal{T}) \cap \mathcal{A}} c(u, w)
    \end{align*}
\end{definition}

\begin{lemma}[]{$s$-$t$-cut}
    Given $f$ is a flow and $(\mathcal{S}, \mathcal{T})$ a $s$-$t$-cut in $N = (\mathcal{V}, \mathcal{A}, c, s, t)$, we have
    \begin{align*}
        \text{val}(f) \leq \text{cap}(\mathcal{S}, \mathcal{T})
    \end{align*}
\end{lemma}


\begin{theorem}[]{Max-flow - min-cut}
    Every network $N = (\mathcal{V}, \mathcal{A}, c, s, t)$ fulfills ($f$ a flow, $(\mathcal{S}, \mathcal{T})$ an $s$-$t$-cut)
    \begin{align*}
        \max_{f \in N} \text{val}(f) = \min_{(\mathcal{S}, \mathcal{T}) \in N} \text{cap}(S, T)
    \end{align*}
\end{theorem}

It is easier to calculate the min-cut, since there are only a finite number of $s$-$t$-cuts (albeit exponentially many, i.e. $2^{|\mathcal{V}| - 2}$), thus the importance of the above theorem.
It forms the basis of the algorithms that calculate a solution to the max-flow problem.

An approach to solve the max-flow problem is to use augmenting paths, but the issue with that is that it isn't guaranteed that we will find a max flow in a finite number of steps.

\fhlc{Cyan}{Residual capacity network}

Using a residual capacity graph also known as a residual network, we can solve the max-flow problem in polynomial time.
The concept is simple, yet ingenious: It is simply a network of the remaining capacity (or the exceeded capacity) of an edge $e \in \mathcal{A}$ for a flow $f$

\begin{definition}[]{Residual Network}
    Let $N = (\mathcal{V}, \mathcal{A}, c, s, t)$ be a network without bidirectional edges and let $f$ be a flow in said network $N$. The residual network $N_f = (\mathcal{V}, \mathcal{A}_f, r_f, s, t)$ is given by
    \begin{enumerate}[label=(\arabic*)]
        \item If $e \in \mathcal{A}$ with $f(e) < c(e)$, then edge $e$ is also $\in \mathcal{A}_f$ whereas $r_f(e) := c(e) - f(e)$
        \item If $e \in \mathcal{A}$ with $f(e) > 0$ then edge $e^{\text{opp}}$ in $\mathcal{A}_f$ whereas $r_f(e^{\text{opp}}) = f(e)$
        \item Only edges as described in (1) and (2) can be found in $\mathcal{A}_f$
    \end{enumerate}

    We call $r_f(e), e \in \mathcal{A}$ the \textit{residual capacity} of edge $e$
\end{definition}

When reconstructing a network from the residual network, the original network is given by:
\begin{itemize}
    \item The capacity of an edge $(u, v)$ in the original network is the value of $(u, v)$ and $(v, u)$ in the residual network added (if applicable), where $(u, v)$ is directed \textit{towards} the target.
    \item The flow of an edge is a bit more complicated: An edge that might appear to intuitively not be part of the flow may be and vice-versa.
          Flow preservation is the key: The same amount of fluid has to enter each vertex (that is not $s$ or $t$) has to also exit it again.
          To check if an edge is part of the flow, simply see if the start vertex of the edge has an excess of fluid.
    \item If just one edge is present, the edge is flipped, if two are present, figure out which edge was part of the flow and which one is the remaining capacity.
\end{itemize}
Note: A vertex in the residual network directed towards the \textit{target} is usually the remaining capacity!

\begin{theorem}[]{Maximum Flow}
    A flow $f$ in a network $N = (\mathcal{V}, \mathcal{A}, c, s, t)$ is a maximum flow if and only if there does not exist a directed path between the source and target of the residual network.

    For every such maximum flow there exists a $s$-$t$-cut with $\text{val}(f) = \text{cap}(S, T)$
\end{theorem}



\newpage
\fhlc{Cyan}{Algorithms}

Most algorithms for the max-flow problem use a residual network, where $\mathcal{A}_f$ is the edge-set in the residual network.

\begin{algorithm}
    \caption{\textsc{Ford-Fulkerson}}
    \begin{algorithmic}[1]
        \Procedure{Ford-Fulkerson}{$\mathcal{V}, \mathcal{A}, c, s, t$}
            \State $f \gets 0$ \Comment{Flow is constantly $0$}
            \While{$\exists s$-$t$-path $P$ in $(\mathcal{V}, \mathcal{A}_f)$} \Comment{Augmenting path}
                \State Increase flow along $P$ by minimum residual capacity in $P$
            \EndWhile
            \State \Return $f$ \Comment{Maximum flow}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

The problem with this algorithm is that it may not terminate for irrational capacities. If we however only consider integral networks without bidirectional edges, it can be easily seen that if we denote $U \in \N$ the upper bound for capacities, the time complexity of this algorithm is \tco{nUm} where \tco{m} is the time complexity for constructing residual network.
\begin{theorem}[]{Max-Flow Algorithm}
    If in a network without bidirectional edges and all capacities integral and no larger than $U$, there is an integral max-flow we can compute in \tco{mnU}, whereas $m$ is the number of edges and $n$ the number of vertices in the network.
\end{theorem}

There are more advanced algorithms than this one that can calculate solutions to this problem faster or also for irrational numbers.
For the following two proposition, $m = |E|$ and $n = |V|$, i.e. $m$ is the number of edges and $n$ the number of vertices

\begin{proposition}[]{Capacity-Scaling}
    If in a network all capacities are integral and at most $U$, there exists an integral max-flow that can be computed in \tco{mn(1 + \log(U))}
\end{proposition}

\begin{proposition}[]{Dynamic-Trees}
    The max-flow of a flow in a network can be calculated in \tco{mn\log(n)}
\end{proposition}


\newpage
\fhlc{Cyan}{Bipartite Matching as Flow-Problem}

We can use the concepts of flows to determine matchings in bipartite graphs.

Let $G = (V, E)$ be a bipartite graph, i.e. $\exists$ Partition $(\mathcal{U}, \mathcal{W})$ of $V$ such that $E = \{\{u, w\} \divides u \in \mathcal{U}, w \in \mathcal{W}\}$.
We construct a network $N = (V \dot{\cup} \{s, t\}, \mathcal{A}, c, s, t)$, i.e. to the vertices of $G$, we added a source and a target.
The capacity function is $c(e) = 1$.
We copy the edges from $G$, having all edges be directed ones from vertices in $\mathcal{U}$ to ones in $\mathcal{W}$.
We add edges from the source $s$ to every vertex in $\mathcal{U}$ and from every vertex in $\mathcal{W}$ to the target $t$.

\begin{lemma}[]{Bipartite Matching - Max-Flow}
    The maximum matching in a bipartite graph $G$ is equal to the maximum flow in the network $N$ as described above
\end{lemma}


\fhlc{Cyan}{Edge- and Vertex-disjoint paths}

We can determine the degree of the connectivity of a graph (i.e. the number of vertices / edges that have to be removed that the graph becomes disconnected) by determining how many edge- or vertex-disjoint paths exist between two vertices.
Again, using max-flow, we can solve this problem as follows:

Given an undirected graph $G = (V, E)$ and two vertices $u, v \in V : u \neq v$, we need to define our network $N = (\mathcal{V}, \mathcal{A}, c, s, t)$:
\begin{itemize}
    \item Copy the vertex set $V$ and union it with two new vertices $s$ and $t$ and we thus have $\mathcal{V} = V \cup \{s, t\}$
    \item Add two edges for each undirected edge in $G$, i.e. $\mathcal{A} = E \cup E'$ where $E'$ is has all edge directions reversed
    \item We define the capacity function as $c(e) = 1$
    \item We add two edges $(s, u)$ and $(v, t)$ and set the capacity of these edges to $|V|$. These are the two vertices between which we evaluate the edge-disjoint paths
\end{itemize}

If instead of edge-disjoint paths, we want to find \textit{vertex}-disjoint paths, we simply replace each vertex $x \in V\backslash\{u, v\}$ by $x_{\text{in}}$ and $x_{\text{out}}$ and connect all input-edges to $x_{\text{in}}$ and all output-edges of $x$ to $x_{\text{out}}$


\fhlc{Cyan}{Image segmentation}

We can also use cuts to solve image segmentation, i.e. to split background from foreground. We can translate an image to an undirected graph, since every pixel has four neighbours.
Whatever the pixel values mean in the end, we assume we can deduce two non-negative numbers $\alpha_p$ and $\beta_p$ denoting the probability that $p$ is in the foreground or background respectively.

Since this topic looks to not be too relevant for the exam, a full explanation of this topic can be found in the script on page 186-189


\fhlc{Cyan}{Flows and convex sets}

From the definition of flows we have seen, there is always \textit{at least} one flow, the flow \textbf{0}.

\begin{lemma}[]{Flows}
    Let $f_0$ and $f_1$ be flows in a network $N$ and let $\lambda \in \R : 0 < \lambda < 1$, then the flow $f_{\lambda}$ given by
    \begin{align*}
        \forall e \in \mathcal{A} : f_{\lambda}(e) := (1 - \lambda)f_0(e) + \lambda f_1(e)
    \end{align*}
    is also a flow in $N$. We have
    \begin{align*}
        \text{val}(f_{\lambda}) = (1 - \lambda) \cdot \text{val}(f_0) + \lambda \cdot \text{val}(f_1)
    \end{align*}
\end{lemma}

\begin{corollary}[]{Number of flows in networks}
    \begin{enumerate}[label=(\roman*)]
        \item A network $N$ has either exactly \textit{one} flow (the flow \textbf{0}) or infinitely many flows
        \item A network $N$ has either exactly \textit{one} maximum flow or infinitely many maximum flows
    \end{enumerate}
\end{corollary}


\shade{ForestGreen}{Convex sets}
We define a function $f: \mathcal{A} \rightarrow \R$ that induces a vector $v_f := (f(e_1), f(e_2), \ldots, f(e_m)) \in \R^m$ whereas $e_1, \ldots, e_m$ is an ordering of the vertices of $\mathcal{A}$ where $m = |\mathcal{A}|$.
We can interpret the set of (maximum) flows as a subset of $\R^m$

\begin{definition}[]{Convex set}
    Let $m \in \N$
    \begin{enumerate}[label=(\roman*)]
        \item For $v_0, v_1 \in \R^m$ let $\overline{v_0v_1}:=\{(1 - \lambda v_0) + \lambda v_1 \divides \lambda \in \R, 0 \leq \lambda \leq 1\}$ be the \textit{line segment} connecting $v_0$ and $v_1$
        \item A set $\mathcal{C} \subseteq \R^m$ is called \textit{convex} if for all $v_0, v_1 \in \mathcal{C}$ the whole line segment $\overline{v_0 v_1}$ is in $\mathcal{C}$
    \end{enumerate}
\end{definition}
\textbf{Examples:} Spheres or convex Polytopes (e.g. dice or tetrahedra in $\R^3$)
\begin{theorem}[]{Convex sets}
    The set of flows of a network with $m$ edges, interpreted as vectors is a convex subset of $\R^m$. The set of all maximum flows equally forms a convex subset of $\R^m$
\end{theorem}


\newpage
\subsubsection{Min-Cuts in graphs}
In the following section we use \textit{multigraphs}.
\begin{recall}[]{Multigraph}
    A multigraph is an undirected, unweighted and acyclic graph $G = (V, E)$, where multiple edges are allowed to exist between the same pair of vertices.

    \textit{(Instead of multiple edges, we could also allow weighted edges, but the algorithms and concepts presented here are more easily understandable using multiple edges)}
\end{recall}

\fhlc{Cyan}{Min-Cut Problem}

We define $\mu(G)$ to be the cardinality of the \textit{min-cut} (this is the problem).
This problem is similar to the min-cut problem for flows, only that we have a multigraph now. We can however replace multiple edges with a single, weighted edge, allowing us to use the algorithms discussed above.
Since we need to compute $(n - 1)$ $s$-$t$-cuts, our total time complexity is \tco{n^4 \log(n)}, since we can compute $s$-$t$-cuts in \tco{n^3\log(n)} = \tco{n\cdot m\log(n)}



\fhlc{Cyan}{Edge contraction}

Let $e = \{u, v\}$ be an edge of our usual multigraph $G$.
The \textit{contraction of} $e$ replaces the two vertices $u$ and $v$ with a single vertex denoted $x_{u, v}$, which is incident to all edges any of the two vertices it replaced were incident to, apart from the ones between the two vertices $u$ and $v$.
We call the new graph $G/e$ and $\deg_{G/e}(x_{u, v}) = \deg_G(u) + \deg_G(v) - 2k$ where $k$ denotes the number of edges between $u$ and $v$.

Of note is that there is a bijection: $\text{Edges in G without the ones between $u$ and } v \leftrightarrow \text{Edges in $G/e$}$

\begin{lemma}[]{Edge contraction}
    Let $G$ be a graph and $e$ be an edge of $G$. Then we have that $\mu(G/e) \geq \mu(G)$ and we have equality if $G$ contains a min-cut $\mathcal{C}$ with $e \notin \mathcal{C}$.
\end{lemma}


\fhlc{Cyan}{Random edge contraction}

\begin{algorithm}
    \caption{Random Cut where $G$ is a connected Multigraph}
    \begin{algorithmic}[1]
        \Procedure{Cut}{$G$}
            \While{$|V(G)| > 2$} \Comment{Vertices of $G$}
                \State $e \gets$ uniformly random edge in $G$
                \State $G \gets G/e$
            \EndWhile
            \State \Return Size of a unique cut of $G$
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

If we assume that we can perform edge contraction in \tco{n} and we can choose a uniformly random edge in $G$ in \tco{n} as well, it is evident that we can compute \textsc{Cut}($G$) in \tco{n^2}

\begin{lemma}[]{Random edge contraction}
    If $e$ is uniformly randomly chosen from the edges of multigraph $G$, then we have
    \begin{align*}
        \Pr[\mu(G) = \mu(G/e)] \geq 1 - \frac{2}{n}
    \end{align*}
\end{lemma}

\newpage
\begin{lemma}[]{Correctness of \textsc{Cut}$(G)$}
    To evaluate the correctness of \textsc{Cut}$(G)$, we define
    \begin{align*}
        \hat{p}(G) := \text{Probability that \textsc{Cut}($G$) returns the value } \mu(G)
    \end{align*}
    and let
    \begin{align*}
        \hat{p}(n) := \inf_{G=(V, E), |V| = n}\hat{p}(G)
    \end{align*}
    Then, for all $n \geq 3$ we have
    \begin{align*}
        \hat{p} \geq \left( 1 - \frac{2}{n} \right) \cdot \hat{p}(n - 1)
    \end{align*}
\end{lemma}

\begin{lemma}[]{Probability of Correctness of \textsc{Cut}$(G)$}
    For all $n \geq 2$ we have $\displaystyle \hat{p}(n) \geq \frac{2}{n(n - 1)} = \frac{1}{{n \choose 2}}$
\end{lemma}
Thus, we repeat the algorithm \textsc{Cut}$(G)$ $\lambda {n \choose 2}$ times for $\lambda > 0$ and we return the smallest value we got.
\begin{theorem}[]{\textsc{Cut}$(G)$}
    For the algorithm that runs \textsc{Cut}$(G)$ $\lambda{n \choose 2}$ times we have the following properties:
    \begin{enumerate}[label=(\arabic*)]
        \item Time complexity: \tco{\lambda n^4}
        \item The smallest found value is with probability at least $1 - e^{-\lambda}$ equal to $\mu(G)$
    \end{enumerate}
\end{theorem}
If we choose $\lambda = \ln(n)$, we have time complexity \tco{n^4 \ln(n)} with error probability \textit{at most} $\frac{1}{n}$

Of note is that for low $n$, it will be worth it to simply deterministically determine the min-cut


\newpage
\subsection{Geometric Algorithms}

\subsubsection{Smallest enclosing circle}
\newcommand{\cplane}{C^\text{\textbullet}}
Given a set $P$ of $n$ points in a plane, we want to find a circle $C(P)$ such that $C(P)$ encloses all points of $P$ and whose \textit{radius} is minimal (SEC).
For a circle $C$ we use $\cplane$ for the circular plane enclosed by $C$, including $C$ and we also allow the points in $P$ to lay on $C(P)$.
\begin{lemma}[]{Existence of distinct SEC}
    For each (finite) set of points $P$ in $\R^2$ there exists a distinct smallest enclosing circle $C(P)$
\end{lemma}

The below lemma forms the basis of our algorithm
\begin{lemma}[]{Subset of set of points}
    For each (finite) set of points $P$ in $\R^2$ with $|P| \geq 3$ there exists a subset $Q \subseteq P$ such that $|Q| = 3$ and $C(Q) = C(P)$
\end{lemma}

\begin{algorithm}
    \caption{Smallest Enclosing Circle $C(P)$}
    \begin{algorithmic}[1]
        \Procedure{CompleteEnumeration}{$P$}
            \For{\textbf{all} $Q \subseteq P$ with $|Q| = 3$}
                \State determine $C(Q)$
                \If{$P \subseteq \cplane(Q)$}
                    \State \Return $C(Q)$
                \EndIf
            \EndFor
        \EndProcedure
    \end{algorithmic}
\end{algorithm}
The above algorithm has time complexity \tco{n^4}, which is due to having to check at most ${n \choose 3}$ sets $Q$, for which we can determine $C(Q)$ in constant time, since $|Q| = 3$. We then have to check for each point in $P$ if it is contained in $\cplane(Q)$, which we can do in \tco{n}, since we can check for each point in constant time.

This is quite inefficient and using a randomized algorithm, we can achieve \tco{n \ln(n)}

\begin{algorithm}
    \caption{Smallest Enclosing Circle $C(P)$ randomized}
    \begin{algorithmic}[1]
        \Procedure{CompleteEnumerationRandomized}{$P$}
            \While{\textit{always}}
                \State select $Q \subseteq P$ with $|Q| = 11$ uniformly randomly
                \State determine $C(Q)$
                \If{$P \subseteq \cplane(Q)$}
                    \State \Return $C(Q)$
                \EndIf
                \State double all points in $P$ outside $C(Q)$
            \EndWhile
        \EndProcedure
    \end{algorithmic}
\end{algorithm}
To implement this algorithm, we also need the doubling function: We initialize an array \verb|num| to length $n$ to $1$. \verb|num[i]| now contains the number of copies of the $i$-th point. If the point lays outside $C(Q)$, we can simply set \verb|num[i] = 2 * num[i]|

\newpage
To select $11$ points uniformly randomly in \tco{n}, consider
\begin{lemma}[]{Uniformly random $Q$}
    Let $n_1, \ldots, n_t \in \N$ and $N := \sum_{i = 1}^{t} n_i$. We generate $X \in \{1, \ldots, t\}$ randomly as seen in Algorithm \ref{alg:t-uniformly-random-numbers}

    Then we have $\Pr[X = i] = \frac{n_i}{N}$ for all $i = 1, \ldots, t$
\end{lemma}

\begin{algorithm}
    \caption{Choose uniformly random number}\label{alg:t-uniformly-random-numbers}
    \begin{algorithmic}[1]
        \Procedure{ChooseUniformlyRandom}{$t$}
            \State \Call{UniformInt}{$1, N$}
            \State $x \gets 1$
            \While{$\sum_{i = 1}^{x} n_i < k$}
                \State $x \gets x + 1$
            \EndWhile
            \State \Return $x$
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\begin{lemma}[]{Uniformly random $Q$}
    Let $P$ be a set of $n$ not necessarily different points and for $r \in \N$ let $R$ be uniformly randomly chosen from ${P \choose r}$. Then, the expected number of points of $P$ that are outside $C(R)$ is at most $3 \frac{n - r}{r + 1} \leq 3\frac{n}{r + 1}$
\end{lemma}

\begin{theorem}[]{Correctness of \textsc{CompleteEnumerationRandomized}}
    The algorithm \textsc{CompleteEnumerationRandomized} computes the smallest enclosing circle of $P$ in time \tco{n \log(n)}
\end{theorem}


\fhlc{Cyan}{Sampling Lemma}
\begin{definition}[]{Sampling Lemma helpers}
    Given a finite set $S$, $n := |S|$ and $\phi$ be an arbitrary function on $2^S$ in an arbitrary range. We define
    \begin{align*}
        V(R) = V_{\phi}(R) & := \{ s \in S \divides \phi(R) \cup \{s\} \neq \phi(R) \}       \\
        X(R) = X_{\phi}(R) & := \{ s \in S \divides \phi(R) \backslash \{s\} \neq \phi(R) \}
    \end{align*}
    We call elements in $V(R)$ \textit{violators of} $R$ and elements in $X(R)$ we \textit{call external in} $R$
\end{definition}

The sampling lemma connects the expected number of violating elements to the number of external elements.
\begin{lemma}[]{Sampling Lemma}
    Let $k \in \N, 0 \leq k \leq n$. We set $v_k := \E[|V(R)|]$ and $x_k := \E[|X(R)|]$ where $R$ is a subset of $S$ of cardinality $k$, uniformly randomly selected from ${s \choose k}$. Then we have for $r \in \N, 0 \leq r <n$
    \begin{align*}
        \frac{v_r}{n - r} = \frac{x_{r + 1}}{r + 1}
    \end{align*}
\end{lemma}

\begin{corollary}[]{Expected numbers / ranks}
    If we choose $r$ elements $R$ from a set $A$ of $n$ numbers randomly, the expected rank of the minimum of $R$ in $A$ is exactly $\frac{n - r}{r + 1} + 1 = \frac{n + 1}{r + 1}$.

    If we choose $r$ points $R$ of a set $P$ of $n$ points in a plane randomly, the expected number of points of $P$ that are outside $C(R)$ is at most $3 \frac{n - r}{r + 1}$
\end{corollary}


\newpage
\subsubsection{Convex hull}
\begin{definition}[]{Convex hull}
    Let $S \subseteq \R^d, d \in \N$. The \textit{convex hull}, $\text{conv}(S)$ of $S$ is the cut of all convex sets that contains $S$, i.e.
    \begin{align*}
        \text{conv}(S) := \bigcap_{S\subseteq C \subseteq \R^d} C
    \end{align*}
    where $C$ is convex
\end{definition}
A convex hull is always convex again.


\setcounter{all}{37}
\begin{theorem}[]{JarvisWrap}
    The \verb|JarvisWrap| algorithm can find the convex hull in \tco{nh}, where $h$ is the number of corners of $P$ and $P$ is a set of $n$ points in any position in $\R^2$.
\end{theorem}


\begin{algorithm}
    \caption{JarvisWrap}
    \begin{algorithmic}[1]
        \Procedure{FindNext}{$q$}
            \State Choose $p_0 \in P\backslash\{q\}$ arbitrarily
            \State $q_{next} \gets p_0$
            \For{\textbf{all} $p \in P\backslash \{q, p_0\}$}
                \If{$p$ is to right of $q q_{next}$}
                    $q_{next} \gets p$ \Comment{$qq_{next}$ is vector from $q$ to $q_{next}$}
                \EndIf
            \EndFor
            \State \Return $q_{next}$
        \EndProcedure
        \Procedure{JarvisWrap}{$P$}
            \State $h \gets 0$
            \State $p_{now} \gets$ point in $P$ with lowest $x$-coordinate
            \While{$p_{now} \neq q_0$}
                \State $q_h \gets p_{now}$
                \State $p_now \gets$ \Call{FindNext}{$q_h$}
                \State $h \gets h + 1$
            \EndWhile
            \State \Return $(q_0, q_1, \ldots, q_{h - 1})$
        \EndProcedure
    \end{algorithmic}
\end{algorithm}


\newpage
\fhlc{Cyan}{LocalRepair}
\begin{algorithm}
    \caption{LocalRepair}
    \begin{algorithmic}[1]
        \Procedure{LocalRepair}{$p_1, \ldots, p_n$}
            \State $q_0 \gets q_1$ \Comment{input sorted according to $x$-coordinate}
            \State $h \gets 0$
            \For{$i \in \{2, \ldots, n\}$} \Comment{Lower convex hull, left to right}
                \While{$h > 0$ and $q_h$ is to the left of $q_{h - 1}p_i$} \Comment{$q_{h - 1}p_i$ is a vector}
                    \State $h \gets h - 1$
                \EndWhile
                \State $h \gets h + 1$
                \State $q_h \gets p_i$ \Comment{$(q_0, \ldots, q_h)$ is lower convex hull of $\{p_1, \ldots, p_i\}$}
            \EndFor
            \State $h' \gets h$
            \For{$i \in \{n - 1, \ldots, 1\}$} \Comment{Upper convex hull, right to left}
                \While{$h > h'$ and $q_h$ is to the left of $q_{h - 1}p_i$} \Comment{$q_{h - 1}p_i$ is a vector}
                    \State $h \gets h - 1$
                \EndWhile
                \State $h \gets h + 1$
                \State $q_h \gets p_i$
            \EndFor
            \State \Return $(q_0, \ldots, q_{h - 1})$ \Comment{The corners of the convex hull, counterclockwise}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\setcounter{all}{42}
\begin{theorem}[]{LocalRepair}
    The \verb|LocalRepair| algorithm can find the convex hull of a (in respect to the $x$-coordinate of each point) sorted set $P$ of $n$ points in $\R^2$ in \tco{n}.
\end{theorem}

The idea of the \verb|LocalRepair| algorithm is to repeatedly correct mistakes in the originally randomly chosen polygon. 
The improvement steps add edges to the polygon such that eventually all vertices lay withing the smallest enclosing circle of the polygon. 
