\newsectionNoPB
\subsection{Newton-Verfahren in $n$ Dimensionen}
Sei $D \subseteq \R^n$ und $F: D \rightarrow \R^n$ stetig differenzierbar. Die Nullstelle ist
\rmvspace
\begin{align*}
    x^{(k + 1)} := x^{(k)} - DF(x^{(k)})^{-1} F(x^{(k)})
\end{align*}

\drmvspace
wobei $DF(x^{(k)}) =
    \begin{bmatrix}
        \frac{\partial F_j}{\partial x_k} (x)
    \end{bmatrix}_{j, k = 1, 2, \ldots, n}$ die Jacobi-Matrix von $F$ ist.

Wichtig ist dabei, dass wir \bi{niemals} das Inverse der Jacobi-Matrix (oder irgend einer anderen Matrix) von der Form $s = A^{-1} b$,
sondern immer das Gleichungssystem $As = b$ lösen sollten, da dies effizienter ist:

\begin{code}{python}
def newton_2d(x: np.ndarray, F, DF, tol=1e-12, maxIter=50):
    """ Newton method in 2d using Jacobi Matrix of F"""
    for i in range(maxIter):
        s = np.linalg.solve(DF(x[0], x[1]), F(x[0], x[1]))
        x -= s
        if np.linalg.norm(s) < tol * np.linalg.norm(x): return x, i
    return x, maxIter
\end{code}

Wollen wir aber garantiert einen Fehler kleiner als unsere Toleranz $\tau$ können wir das Abbruchkriterium
\rmvspace
\begin{align*}
    ||DF(x^{(k - 1)})^{-1}F(x^{(k)})|| \leq \tau
\end{align*}

\drmvspace
verwenden. Code, welcher dies implementiert findet sich auf Seite 213-216 im Skript.
