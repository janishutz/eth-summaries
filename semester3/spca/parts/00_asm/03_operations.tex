\subsection{Operations}
Assembly operations include performing arithmetic or logic functions on registers or memory data,
transferring data between memory and registers and transferring control (conditional or unconditional jumps).\\
Note that \verb|move| instructions \textit{cannot} move data directly from memory to memory.

The following instruction formats are commonly used:

\inputcodewithfilename{gas}{code-examples/01_asm/}{00_operations.s}

Arithmetic / logic operations need a size postfix (replace \texttt{X} below with \texttt{b} (1B), \texttt{w} (2B), \texttt{l} (4B) or \texttt{q} (8B)).
\begin{tables}{lll}{Mnemonic & Format             & Computation}
              \texttt{addl}  & \texttt{Src, Dest} & \texttt{Dest} $\gets$ \texttt{Dest + Src}               \\
              \texttt{subX}  & \texttt{Src, Dest} & \texttt{Dest} $\gets$ \texttt{Dest - Src}               \\
              \texttt{imulX} & \texttt{Src, Dest} & \texttt{Dest} $\gets$ \texttt{Dest * Src}               \\
              \texttt{salX}  & \texttt{Src, Dest} & \texttt{Dest} $\gets$ \texttt{Dest << Src}              \\
              \texttt{sarX}  & \texttt{Src, Dest} & \texttt{Dest} $\gets$ \texttt{Dest >> Src} (arithmetic) \\
              \texttt{shrX}  & \texttt{Src, Dest} & \texttt{Dest} $\gets$ \texttt{Dest >> Src} (logical)    \\
              \texttt{xorX}  & \texttt{Src, Dest} & \texttt{Dest} $\gets$ \texttt{Dest \string^ Src}        \\
              \texttt{andX}  & \texttt{Src, Dest} & \texttt{Dest} $\gets$ \texttt{Dest \& Src}              \\
              \texttt{orX}   & \texttt{Src, Dest} & \texttt{Dest} $\gets$ \texttt{Dest | Src}               \\
              \texttt{incX}  & \texttt{Dest}      & \texttt{Dest} $\gets$ \texttt{Dest + 1}                 \\
              \texttt{decX}  & \texttt{Dest}      & \texttt{Dest} $\gets$ \texttt{Dest - 1}                 \\
              \texttt{negX}  & \texttt{Dest}      & \texttt{Dest} $\gets$ \texttt{-Dest}                    \\
              \texttt{notX}  & \texttt{Dest}      & \texttt{Dest} $\gets$ \texttt{\string~Dest}             \\
\end{tables}

\newpage
\subsubsection{Condition Codes}
Any arithmetic operation (that is truly part of the arithmetic operations group, so not including \texttt{lea} for example) implicitly sets the \bi{condition codes}.
The following condition codes were covered in the lecture (operation: \texttt{t = a + b}):
\begin{itemize}
    \item \texttt{CF} (Carry Flag): Set if carry out from MSB (unsigned overflow)
    \item \texttt{ZF} (Zero Flag): Set if \texttt{t == 0}
    \item \texttt{SF} (Sign Flag): Set if \texttt{(a - b) < 0} (for signed)
    \item \texttt{OF} (Overflow Flag): Set if two's complement overflow (i.e. \verb+(a>0 && b>0 && t<0) || (a<0 && b<0 && t>=0)+)
\end{itemize}

\content{Explicit computation}
In the below explanations, we always assume \texttt{src2 = b} and \texttt{src1 = a}

To explicitly compute them, we can use the \texttt{cmpX src2, src1} instruction (with X again any of the size postfixes),
that essentially computes $(a - b)$ without setting a destination register.
When we execute that instruction, \texttt{CF} is set if \texttt{a < b} (unsigned), \texttt{ZF} is set if \texttt{a == b}, \texttt{SF} is set if \texttt{a < b} (signed)
and \texttt{OF} is set as above, where \texttt{t = a - b}.

Another instruction that is used is \texttt{testX src2, src1} (X again a size postfix), and acts like computing \texttt{a \& b} and where \texttt{ZF} is set if \texttt{a \& b == 0}
and \texttt{SF} is set if \texttt{a \& b < 0}.

\content{Zeroing register} We can use a move instruction, but that is less efficient than using \texttt{xorl reg, reg}, where \texttt{reg} is the 32-bit version of the reg we want to zero.

\content{Reading condition codes} To read condition codes, we can use the \texttt{setX} instructions, where the \texttt{X} is to be substituted by an element of table \ref{tab:condition-codes}

\content{Jumping} To jump, we have the \texttt{jmp <label>} instruction (unconditional jump) or the \texttt{jX} instructions, with \texttt{X} from table \ref{tab:condition-codes}

\begin{table}[h!]
    \begin{tables}{lll}{\texttt{setX} & Condition           & Description}
              \texttt{e}          & \verb|ZF|           & Equal / Zero              \\
              \texttt{ne}         & \verb+~ZF+          & Not Equal / Not Zero      \\
              \texttt{s}          & \verb|SF|           & Negative                  \\
              \texttt{ns}         & \verb+~SF+          & Nonnegative               \\
              \texttt{g}          & \verb+~(SF^OF)&~ZF+ & Greater (signed)          \\
              \texttt{ge}         & \verb+~(SF^OF)+     & Greater or equal (signed) \\
              \texttt{l}          & \verb+SF^OF+        & Less (signed)             \\
              \texttt{le}         & \verb+(SF^OF)|ZF+   & Less or equal (signed)    \\
              \texttt{a}          & \verb+~CF&~ZF+      & Above (unsigned)          \\
              \texttt{b}          & \verb|CF|           & Below (unsigned)          \\
    \end{tables}
    \caption{Condition code postfixes for jump and set instructions}
    \label{tab:condition-codes}
\end{table}

\content{Conditional Moves}

Similar to \texttt{jX}, the same postfixes can be applied to \texttt{cmovX}, for example:

\begin{minted}{gas}
    cmpl     %eax, %edx
    cmovle   %edx, %eax
\end{minted}

Will move \verb|%edx| into \verb|%eax|, only if \verb|%edx| is less or equal (\verb|le|) \verb|%eax|.

This can be used to, for example, compile ternary expressions from \verb|C| to Assembly. However, this requires evaluating both possible expressions, which may lead to a (significant) performance overhead.