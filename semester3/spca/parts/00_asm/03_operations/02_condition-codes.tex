\subsubsection{Condition Codes}
Any arithmetic operation (that is truly part of the arithmetic operations group, so not including \texttt{lea} for example) implicitly sets the \bi{condition codes}.
The following condition codes were covered in the lecture (operation: \texttt{t = a + b}):
\begin{itemize}
    \item \texttt{CF} (Carry Flag): Set if carry out from MSB (unsigned overflow)
    \item \texttt{ZF} (Zero Flag): Set if \texttt{t == 0}
    \item \texttt{SF} (Sign Flag): Set if \texttt{(a - b) < 0} (for signed)
    \item \texttt{OF} (Overflow Flag): Set if two's complement overflow (i.e. \verb+(a>0 && b>0 && t<0) || (a<0 && b<0 && t>=0)+)
\end{itemize}

\content{Explicit computation}
In the below explanations, we always assume \texttt{src2 = b} and \texttt{src1 = a}

To explicitly compute them, we can use the \texttt{cmpX src2, src1} (i.e. for easier understanding, \texttt{cmpX b, a}) instruction (with X again any of the size postfixes),
that essentially computes $(a - b)$ without setting a destination register.

When we execute that instruction, \texttt{CF} is set if \texttt{a < b} (unsigned), \texttt{ZF} is set if \texttt{a == b}, \texttt{SF} is set if \texttt{a < b} (signed)
and \texttt{OF} is set as above, where \texttt{t = a - b}.

Another instruction that is used is \texttt{testX src2, src1} (X again a size postfix, easier: \texttt{testX b, a}), and acts like computing \texttt{a \& b} and where \texttt{ZF} is set if \texttt{a \& b == 0}
and \texttt{SF} is set if \texttt{a \& b < 0}.

\content{Zeroing register} We can use a move instruction, but that is less efficient than using \texttt{xorl reg, reg},
where \texttt{reg} is the 32-bit version of the reg we want to zero. This works because on 32-bit operations,
the upper 32 bit of the 64 bit register will be zeroed.

\content{Reading condition codes} To read condition codes, we can use the \texttt{setC} instructions,
where the \texttt{C} is to be substituted by an element of table \ref{tab:condition-codes}
