\newpage
\subsection{NP-Vollständigkeit}
Es sind mittlerweile über 3000 Probleme bekannt, für welche wir keinen Algorithmus kennen, der in polynomieller Zeit läuft.
Es ist aber bis jetzt niemandem gelungen, eine höhere untere Schranke für alle zu beweisen, als $\tcl{n}$.

Wie bereits bei der Berechenbarkeit benutzen wir eine Reduktion.
Falls jedes Problem aus $NP$ effizient auf ein Problem $L \in NP$ reduzierbar ist, so ist $L$ schwer.

\begin{definition}[]{Polynomielle Reduktion}
    $L_1 \subseteq \word_1$ ist \bi{polynomiell reduzierbar auf} $L_2 \subseteq \word_2$, geschrieben $L_1 \leq_p L_2$,
    falls eine polynomielle TM $A$ existiert, die für jedes Wort $x \in \word_1$ ein Word $A(x) \in \word_2$ berechnet, so dass
    \rmvspace
    \begin{align*}
        x \in L_1 \Longleftrightarrow A(x) \in L_2
    \end{align*}

    \drmvspace
    $A$ wird eine polynomielle Reduktion von $L_1$ auf $L_2$ genannt.
\end{definition}
Wieder bedeutet $L_1 \leq_p L_2$, dass $L_2$ mindestens so schwer ist wie $L_1$

\begin{definition}[]{$NP$-Schwer}
    Eine Sprache $L$ ist \bi{$NP$-Schwer}, falls für alle $L' \in NP$ gilt $L' \leq_p L$.

    Eine Sprache $L$ ist \bi{$NP$-Vollständig}, falls
    \drmvspace
    \begin{multicols}{2}
        \begin{enumerate}[label=\textit{(\roman*)}]
            \item $L \in NP$
            \item $L$ $NP$-Schwer ist.
        \end{enumerate}
    \end{multicols}
\end{definition}


\inlinelemma Falls $L \in P$ und $L$ ist $NP$-schwer, dann gilt $P = NP$

\fancytheorem{Cook} $SAT$ ist $NP$-Vollständig

Der Beweis hierfür liefert eine grobe Struktur für weitere Beweise dieser Art und ist auf Seiten 199 - 205 im Buch (= Seiten 211 - 217 im PDF) zu finden.
Jedoch sind diese Beweise sehr gross und deshalb nicht prüfungsrelevant.


\inlinelemma Falls $L_1 \leq_p L_2$ und $L_1$ ist $NP$-Schwer, so ist auch $L_2$ $NP$-Schwer

Betrachten wir folgende Sprachen:
\begin{align*}
    SAT    & = \{ \Phi \divides \Phi \text{ ist eine erfüllbare Formel in CNF} \}                                                   \\
    CLIQUE & = \{ (G, k) \divides G \text{ ist ein ungerichteter Graph, der eine $k$-clique enthält} \}                             \\
    VC     & = \{ (G, k) \divides G \text{ ist ein ungerichteter Graph mit einer Kontenüberdeckung der Mächtigkeit höchstens } k \}
\end{align*}
Wir erinnern uns daran, dass eine Kontenüberdeckung eines Graphen $G = (V, E)$ jede Menge von Konten $U \subseteq V$ ist,
so dass jede Kante aus $E$ mindestens einen Endpunkt in $U$ hat.

\inlinelemma $SAT \leq_p CLIQUE$

\inlinelemma $CLIQUE \leq_p VC$

\inlinelemma $SAT \leq_p 3SAT$, wobei wir beim $3SAT$-Problem bestimmen wollen, ob eine Formel in $3CNF$ (CNF, aber alle Klauseln enthalten höchstens $3$ Variabeln) erfüllbar ist.


\begin{definition}[]{$NPO$}
    $NPO$ ist die Klasse der Optimierungsprobleme, mit $U = (\Sigma_I, \Sigma_O, L, \cM, \text{cost}, \text{goal}) \in NPO$, falls folgende Bedingungen erfüllt sind:
    \begin{enumerate}[label=\textit{(\roman*)}]
        \item $L \in P$
        \item Es existiert ein Polynom $p_U$, so dass
              \begin{enumerate}[label=(\alph*)]
                  \item Für jedes $x \in L$ und jedes $y \in \cM(x)$
                  \item es existiert ein polynomieller Algorithmus $A$, der für jedes $y \in \word_O$ und jedes $x \in L$ mit $|y| \leq p_U(|x|)$ entscheidet,
                        ob $y \in \cM(x)$ oder nicht
              \end{enumerate}
        \item Die Funktion $\text{cost}$ kann man in polynomieller Zeit berechnen.
    \end{enumerate}
\end{definition}

\newpage
Ein Optimierungsproblem $U$ ist also in $NPO$, falls
\rmvspace
\begin{enumerate}[noitemsep]
    \item man effizient überprüfen kann, ob ein gegebenes Wort ein Problemfall von $U$ ist
    \item die Grösse der Lösungen polynomiell in der Grösse des Problemfalls (Eingabe) und in polynomieller Zeit verifizert werden kann,
          ob $y$ eine zulässige Lösung für einen gegebenen Problemfall ist
    \item man die Kosten der zulässigen Lösung effizient berechnen kann
\end{enumerate}

$\text{MAX-SAT}$ liegt in $NPO$

\begin{definition}[]{PO}
    $PO$ ist die Klasse von Optimierungsproblemen $U = (\Sigma_I, \Sigma_O, L, \cM, \text{cost}, \text{goal})$, so dass
    \begin{enumerate}[label=(\roman*)]
        \item $U \in NPO$
        \item $\exists$ polynomieller Algorithmus $A$, so dass $A(x)$ für jedes $x \in L$ die optimale Lösung für $x$ ist.
    \end{enumerate}
\end{definition}

\begin{definition}[]{Schwellenwert-Sprache}
    Die Schwellenwert-Sprache für $U$ (ein Optimierungsproblem aus $NPO$) ist
    \rmvspace
    \begin{align*}
        \text{Lang}_U = \{ (x, a) \in L \times \wordbool \divides \text{Opt}_U(x) \leq \text{Nummer}(a) \}
    \end{align*}

    \rmvspace
    mit $\text{Opt}_U(x)$ die optimale Lösung, falls $\text{goal} = \text{Minimum}$, und
    \rmvspace
    \begin{align*}
        \text{Lang}_U = \{ (x, a) \in L \times \wordbool \divides \text{Opt}_U(x) \leq \text{Nummer}(a) \}
    \end{align*}

    \rmvspace
    falls $\text{goal} = \text{Maximum}$

    Wir sagen, dass $U$ \bi{NP-schwer} ist, falls $\text{Lang}_U$ NP-schwer ist.
\end{definition}

\inlinelemma Falls ein Optimierungsproblem $U \in PO$, dann $\text{Lang}_U \in P$

\inlinetheorem Sei $U \in NPO$. Falls $U$ NP-schwer ist und $P \neq NP$, dann $U \notin PO$

\inlinelemma MAX-SAT ist NP-schwer.

\inlinelemma MAX-CL (Das Problem der maximalen Clique) ist NP-schwer

Um zu zeigen, dass solche Probleme $U$ NP-schwer sind, reicht es zu zeigen, dass $\text{Lang}_U$ NP-schwer ist, was wir mit einer $P$-Reduktion machen können.
