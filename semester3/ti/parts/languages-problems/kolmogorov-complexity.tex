\newpage
\subsection{Kolmogorov-Komplexität}
\setcounter{definitions}{17}
Falls ein Wort $x$ eine kürzere Darstellung hat, wird es \bi{komprimierbar genannt} und wir nennen die Erzeugung dieser Darstellung eine \bi{Komprimierung} von $x$.

Eine mögliche Idee, um den Informationsgehalt eines Wortes zu bestimmen, wäre einem komprimierbaren Wort einen kleinen Informationsgehalt zuzuordnen und einem unkomprimierbaren Wort einen grossen Informationsgehalt zuzuordnen.

Wenn wir also das Wort $011011011011011011011011$ haben, so kann man es auch als $(011)^8$ darstellen und hat so also einen kleineren Informationsgehalt als bspw. $0101101000101101001110110010$.

Die Idee mit der Komprimierung den Informationsgehalt zu bestimmen ist jedoch nicht ideal, da für jede Komprimierung bei unendlich langen Wörtern immer eine weitere Komprimierung existiert, die für unendlich viele Wörter besser geeignet ist.

Hier kommt die Kolmogorov-Komplexit zum Zuge: Sie bietet eine breit Gültige Definition des Komplexitätsmasses.


\begin{definition}[]{Kolmogorov-Komplexität}
	Für jedes Wort $x \in \wordbool$ ist die \bi{Kolmogorov-Komplexität $K(x)$ des Wortes $x$} das Minimum der binären Längen der Pascal-Programme, die $x$ generieren.
\end{definition}

Hierbei ist mit der binären Länge die Anzahl Bits gemeint, die beim Übersetzen des Programms in einen vordefinierten Maschinencode entsteht.

Ein Pascal-Programm in diesem Kurs ist zudem nicht zwingend ein Programm in der effektiven Programmiersprache Pascal, sondern eine Abwandlung davon, worin es auch erlaubt ist, gewisse Prozesse zu beschreiben und nicht als Code auszuformulieren, da das nicht das Ziel dieses Kurses ist.


\begin{lemma}[]{Kolmogorov-Komplexität}
	Für jedes Wort $x \in \wordbool$ existiert eine Konstante $d$ so dass $K(x) \leq |x| + d$
\end{lemma}
\inlineproof Für jedes $x \in \wordbool$ kann folgendes Programm $A_x$ verwendet werden:

\begin{code}{pascal}
$A_x$: begin
        write(x);
     end
\end{code}
Alle Teile, ausser $x$ sind dabei von konstanter Länge, also ist die Länge der Bit-repräsentation des Programms ausschliesslich von der binären Länge des Wortes $x$ abhängig.

\proven


Für regelmässige Wörter gibt es natürlich Programme, bei denen das Wort nicht als komplette Variable vorkommt.
Deshalb haben diese Wörter auch (meist) eine kleinere Kolmogorov-Komplexität.


\fancydef{$K(n)$ für $n \in \N$} Die \bi{Kolmogorov-Komplexität einer natürlichen Zahl $n$} ist $K(n) = K(\text{Bin}(n))$,
wobei $\text{Bin}(x) = \ceil{\log_2(x + 1)}$ % TODO: Verify correctness here

\inlinelemma Für jede Zahl $n \in \N - \{ 0 \}$ existiert ein Wort $w_n \in (\alphabets{bool})^n$ so dass $K(w_n) \geq |w_n| = n$, oder in Worten, es existiert für jedes $n$ ein nicht komprimierbares Wort.

Eine wichtige Eigenschaft der Kolmogorov-Komplexität ist, dass sie nicht wirklich von der gewählten Programmiersprache abhängt.
Man kann also beliebig auch \texttt{C++}, \texttt{Swift}, \texttt{Python}, \texttt{Java} oder welche auch immer, ohne dass die Kolmogorov-Komplexität um mehr als eine Konstante wächst (auch wenn diese bei \texttt{Java} sehr gross ist):

\begin{theorem}[]{Unterschiedliche Programmiersprachen}
	Für jede Programmiersprachen $A$ und $B$ existiert eine Konstante $c_{A,B}$, die nur von $A$ und $B$ abhängig ist, so dass für alle $x \in \wordbool$ gilt:
	\begin{align*}
		|K_A(x) - K_B(x)| \leq c_{A, B}
	\end{align*}
\end{theorem}

\fhlc{orange}{Anwendungen der Kolmogorov-Komplexität}

\shade{orange}{Zufall} Der Zufall ist ein intuitiver, aber nicht sehr formeller Begriff, der mit der Kolmogorov-Komplexität formalisiert werden kann:
\begin{definition}[]{Zufall}
    Ein Wort $x \in \wordbool$ (eine Zahl $n$) heisst \bi{zufällig}, falls $K(x) \geq |x|$ ($K(n) = K(\text{Bin}(n)) \geq \ceil{\log_2(n + 1)} - 1$)
\end{definition}

\shade{orange}{Existenz eines Programms vs Kolmogorov-Komplexität} 
\begin{theorem}[]{Programm vs Komplexität}
    Sei $L$ eine Sprache über $\alphabets{bool}$ und für jedes $n \in \N - \{0\}$ sei $z_n$ das $n$-te Wort in $L$ bezüglich der kanonischen Ordnung.
    Falls ein Programm $A_L$ existiert, das das Entscheidungsproblem $(\alphabets{bool}, L)$ löst, so gilt für alle $n \in \N - \{ 0 \}$ dass
    \begin{align*}
        K(z_n) \leq \ceil{\log_2(n + 1)} + c & & (c \text{ ist eine von } n \text{ unabhängige Konstante })
    \end{align*}
\end{theorem}

\shade{orange}{Primality testing}
\begin{theorem}[]{Primzahlensatz}
    \vspace{-0.3cm}
    \begin{align*}
        \limni \frac{\text{Prim}(n)}{\frac{n}{\ln(n)}} = 1
    \end{align*}
\end{theorem}
Die Annäherung von $\text{Prim}(n)$ and $\frac{n}{\ln(n)}$ wird durch folgende Ungleichung gezeigt:
\begin{align*}
    \ln(n) - \frac{3}{2} < \frac{n}{\text{Prim}(n)} < \ln(n) - \frac{1}{2} \smallhspace \forall n \geq 67 \in \N
\end{align*}

\begin{lemma}[]{Anzahl Primzahlen mit Eigenschaften}
    Sei $n_1, n_2, \ldots$ eine stetig steigende unendliche Folge natürlicher Zahlen mit $K(n_i) \geq \frac{\ceil{\log_2(n_i)}}{2}$.
    Für jedes $i \in \N - \{ 0 \}$ sei $q_i$ die grösste Primzahl, die $n_i$ teilt. 
    Dann ist die Menge $Q = \{ q_i \divides i \in \N - \{ 0 \} \}$
\end{lemma}
